---
description: When a new database model is created 
alwaysApply: false
---

# Database Models Guide

This project uses SQLAlchemy 2.0+ with programmatic model discovery.

## Creating New Models

### 1. Create Model File
Create new model files in `src/db/models/` (typically in a schema subdirectory like `public/`) following this template:

```python
from sqlalchemy import (
    Column,
    String,
    DateTime,
    Boolean,
    Integer,
    ForeignKey,
    ForeignKeyConstraint,
    Index,
    CheckConstraint,
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.sql import func
from src.db.models import Base
import uuid
import enum
from datetime import datetime, timezone


class YourEnum(enum.Enum):
    VALUE_ONE = "VALUE_ONE"
    VALUE_TWO = "VALUE_TWO"


class YourModel(Base):
    __tablename__ = "your_table_name"
    __table_args__ = (
        # Foreign key constraints
        ForeignKeyConstraint(
            ["foreign_key_id"],
            ["other_table.id"],
            name="your_table_foreign_key_fkey",
            ondelete="SET NULL",
        ),
        # Indexes for performance
        Index("idx_your_table_field", "field_name"),
        # Data validation constraints
        CheckConstraint(
            "field_name >= 0",
            name="check_field_name_positive",
        ),
        {"schema": "public"},
    )

    # Row-Level Security (RLS) policies
    __rls_policies__ = {
        "user_owns_row": {
            "command": "SELECT",
            "using": "user_id = auth.uid()",
        },
        "admin_access": {
            "command": "SELECT",
            "using": "current_setting('app.user_role') = 'admin'",
        },
    }

    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Your fields here
    name = Column(String, nullable=False)
    
    # Timestamps (always include these)
    created_at = Column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
    )
    updated_at = Column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
        nullable=False,
    )
```

### 2. Export the Model
**CRITICAL**: Add your new model to the appropriate schema `__init__.py` file (e.g., `src/db/models/public/__init__.py`):

```python
from .your_model import YourModel, YourEnum

__all__ = [
    # ... existing exports ...
    "YourModel",
    "YourEnum",
]
```

**NOTE**: With the new automated model discovery system, models will be automatically discovered. However, you should still export models from schema `__init__.py` files for explicit imports and better organization.

### 3. Required Fields
Every model must include:
- **Primary key**: UUID with `default=uuid.uuid4`
- **Timestamps**: `created_at` and `updated_at` with timezone support
- **Schema specification**: `{"schema": "public"}` in `__table_args__`

### 4. Naming Conventions
- **Class names**: PascalCase (e.g., `MCPListings`)
- **Table names**: snake_case (e.g., `mcp_listings`)
- **Field names**: snake_case (e.g., `created_at`)
- **Enum names**: PascalCase (e.g., `DeploymentType`)
- **Enum values**: UPPER_CASE (e.g., `LOCAL`, `REMOTE`)

### 5. Row-Level Security (RLS) Policies

You can define RLS policies directly in your model using the `__rls_policies__` attribute. These policies will be automatically detected and included in database migrations.

#### RLS Policy Structure
The `__rls_policies__` attribute is a dictionary where keys are policy names and values are policy configurations:

```python
__rls_policies__ = {
    "policy_name": {
        "command": "SELECT",                    # Required: SQL command (SELECT, INSERT, UPDATE, DELETE, or ALL)
        "using": "user_id = auth.uid()",        # Required: USING clause for the policy
        "check": "user_id = auth.uid()",        # Optional: CHECK clause (for INSERT/UPDATE policies)
        "permissive": True,                     # Optional: True for PERMISSIVE (default), False for RESTRICTIVE
    }
}
```

#### Common RLS Patterns

**User-owned rows pattern:**
```python
__rls_policies__ = {
    "user_owns_row": {
        "command": "SELECT",
        "using": "user_id = auth.uid()",
    }
}
```

**Full user control (CRUD operations):**
```python
__rls_policies__ = {
    "user_owns_row": {
        "command": "ALL",
        "using": "user_id = auth.uid()",
        "check": "user_id = auth.uid()",
    }
}
```

**Organization-based access:**
```python
__rls_policies__ = {
    "organization_access": {
        "command": "SELECT",
        "using": "organization_id = current_setting('app.current_organization')::uuid",
    }
}
```

**Role-based access:**
```python
__rls_policies__ = {
    "admin_full_access": {
        "command": "ALL",
        "using": "current_setting('app.user_role') = 'admin'",
    },
    "user_read_only": {
        "command": "SELECT",
        "using": "current_setting('app.user_role') = 'user'",
    }
}
```

**Multi-tenant pattern:**
```python
__rls_policies__ = {
    "tenant_isolation": {
        "command": "SELECT",
        "using": "tenant_id = current_setting('app.current_tenant')::uuid",
    }
}
```

**Global read with owner write pattern:**
```python
__rls_policies__ = {
    "global_read_access": {
        "command": "SELECT",
        "using": "true",
    },
    "owner_full_access": {
        "command": "ALL",
        "using": "organization_id IN (SELECT id FROM public.organizations WHERE owner_user_id = auth.uid())",
        "check": "organization_id IN (SELECT id FROM public.organizations WHERE owner_user_id = auth.uid())",
    },
}
```

**Multi-owner pattern (profile or organization):**
```python
__rls_policies__ = {
    "global_read_access": {
        "command": "SELECT",
        "using": "true",
    },
    "owner_full_access": {
        "command": "ALL",
        "using": "(owner_profile_id = auth.uid() OR owner_organization_id IN (SELECT id FROM public.organizations WHERE owner_user_id = auth.uid()))",
        "check": "(owner_profile_id = auth.uid() OR owner_organization_id IN (SELECT id FROM public.organizations WHERE owner_user_id = auth.uid()))",
    },
}
```

#### RLS Policy Migration

When you run `make db_migration msg="Add RLS policies"`, Alembic will:

1. **Enable RLS** on the table if not already enabled
2. **Create new policies** that don't exist in the database
3. **Generate SQL** like:

```sql
ALTER TABLE public.your_table_name ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_owns_row ON public.your_table_name
    AS PERMISSIVE
    FOR SELECT
    USING (user_id = auth.uid());
```

#### Policy Clauses

- **USING clause**: Controls which existing rows are visible for SELECT operations and which rows can be affected by UPDATE/DELETE operations
- **CHECK clause**: Controls which new rows can be inserted or which values can be set during UPDATE operations
- **FOR SELECT**: Only uses the USING clause (CHECK clause is ignored)
- **FOR INSERT**: Only uses the CHECK clause (USING clause is ignored)
- **FOR UPDATE**: Uses both USING (to identify updatable rows) and CHECK (to validate new values)
- **FOR DELETE**: Only uses the USING clause (CHECK clause is ignored)
- **FOR ALL**: Uses both clauses as appropriate for each operation

#### Important Notes

- **User identification**: Use `auth.uid()` to get the current authenticated user's ID in RLS policies
- **Current settings**: Use PostgreSQL's `current_setting()` function for application-level variables like roles, organizations, etc.
- **Security context**: Your application must set context variables using `SET LOCAL` in each transaction
- **Policy testing**: Always test RLS policies in a development environment first
- **Performance**: RLS policies are evaluated on every query, so keep expressions efficient
- **Clean migrations**: Only RLS policy changes will be included in migrations; schema drift operations are automatically filtered out



## Foreign Key Best Practices

### 1. Use Schema Prefixes
Always use explicit schema prefixes in foreign key references to avoid resolution issues:

```python
ForeignKeyConstraint(
    ["user_id"],
    ["public.profiles.user_id"],  # ✅ CORRECT: explicit schema prefix
    name="your_table_user_id_fkey",
    ondelete="CASCADE",
)
```

**❌ AVOID:**
```python
ForeignKeyConstraint(
    ["user_id"],
    ["profiles.user_id"],  # ❌ WRONG: missing schema prefix
    name="your_table_user_id_fkey",
    ondelete="CASCADE",
)
```

### 2. Handle Circular Dependencies
For models with circular dependencies, use `use_alter=True` to defer foreign key creation:

```python
ForeignKeyConstraint(
    ["organization_id"],
    ["public.organizations.id"],
    name="your_table_organization_id_fkey",
    ondelete="SET NULL",
    use_alter=True,  # ✅ CORRECT: defer FK creation for circular deps
)
```

### 3. Recommended Helper Function
Use the foreign key management utility for automatic `use_alter` detection:

```python
from src.db.utils.foreign_key_manager import create_foreign_key_constraint

# In your model's __table_args__:
create_foreign_key_constraint(
    columns=["user_id"],
    referred_columns=["user_id"],
    referred_table="profiles",
    schema="public",
    referred_schema="public",
    name="your_table_user_id_fkey",
    ondelete="CASCADE"
)
```

### 4. Index Foreign Keys
Always create indexes for foreign key columns:

```python
Index("idx_your_table_user_id", "user_id"),
```

## Migration Validation

### Before Creating Migrations
**ALWAYS** run migration validation before creating new migrations:

```bash
# Quick validation
make db_validate

# Full validation with detailed report
rye run python -m src.db.utils.migration_validator --verbose

# Strict validation (treat warnings as errors)
rye run python -m src.db.utils.migration_validator --strict
```

### Pre-flight Checks
Before running migrations in production, always run pre-flight checks:

```bash
# Complete pre-flight check
rye run python -m src.db.utils.migration_validator --preflight
```

### Common Migration Issues and Solutions

#### 1. Missing Model Imports
**Problem**: `NoReferencedTableError` when creating migrations
**Solution**: Ensure all models are imported in schema `__init__.py` files

#### 2. Circular Dependencies
**Problem**: Foreign key resolution fails due to circular references
**Solution**: Use `use_alter=True` on foreign key constraints in the dependency cycle

#### 3. Missing Schema Prefixes
**Problem**: Table resolution issues in complex schemas
**Solution**: Always use explicit schema prefixes (`public.table_name.column_name`)

#### 4. Transaction Abort Issues
**Problem**: `InFailedSqlTransaction` errors during migration
**Solution**: Never use `use_alter=True` in `create_table` statements - only in model definitions

## Migration Testing

### 1. Test Locally First
Always test migrations on a development database before production:

```bash
# Test current migration
make db_migrate

# Test rollback
make db_downgrade

# Test forward again
make db_migrate
```

### 2. Validate Migration Success
After running migrations, verify they worked correctly:

```bash
# Check migration status
make db_status

# Validate database connection
make db_test
```

### 3. Monitor for Issues
Watch for these common post-migration issues:
- Foreign key constraint violations
- RLS policy conflicts
- Index performance problems
- Data type mismatches

## Automatic Discovery

Models are automatically discovered from schema packages using the new model discovery system. The system will:

1. **Scan** all Python files in `src/db/models/` subdirectories
2. **Import** modules and extract SQLAlchemy models
3. **Validate** that all models have required attributes
4. **Report** any missing or problematic models

Manual imports in `src/db/models/__init__.py` are still maintained for backward compatibility and explicit control.